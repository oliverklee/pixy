package at.ac.tuwien.infosys.www.pixy;

import java.util.*;

import at.ac.tuwien.infosys.www.pixy.analysis.dependency.DependencyAnalysis;
import at.ac.tuwien.infosys.www.pixy.analysis.dependency.Sink;
import at.ac.tuwien.infosys.www.pixy.analysis.dependency.graph.AbstractNode;
import at.ac.tuwien.infosys.www.pixy.analysis.dependency.graph.BuiltinFunctionNode;
import at.ac.tuwien.infosys.www.pixy.analysis.dependency.graph.DependencyGraph;
import at.ac.tuwien.infosys.www.pixy.analysis.dependency.graph.NormalNode;
import at.ac.tuwien.infosys.www.pixy.analysis.dependency.graph.UninitializedNode;
import at.ac.tuwien.infosys.www.pixy.conversion.AbstractTacPlace;
import at.ac.tuwien.infosys.www.pixy.conversion.Constant;
import at.ac.tuwien.infosys.www.pixy.conversion.InternalStrings;
import at.ac.tuwien.infosys.www.pixy.conversion.Literal;
import at.ac.tuwien.infosys.www.pixy.conversion.TacFunction;
import at.ac.tuwien.infosys.www.pixy.conversion.Variable;
import at.ac.tuwien.infosys.www.pixy.conversion.cfgnodes.AbstractCfgNode;
import at.ac.tuwien.infosys.www.pixy.conversion.cfgnodes.CallUnknownFunction;

public abstract class AbstractVulnerabilityAnalysis {

	protected DependencyAnalysis depAnalysis;
	protected VulnerabilityAnalysisInformation dci;

	public enum InitialTaint {
		ALWAYS, IFRG, NEVER
	}

	protected boolean getIsTainted = true;

	protected AbstractVulnerabilityAnalysis(DependencyAnalysis depAnalysis) {
		this.depAnalysis = depAnalysis;
		this.dci = MyOptions.getDepClientInfo(this.getClass().getName());
	}

	public abstract List<Integer> detectVulns();

	public abstract VulnerabilityInformation detectAlternative();

	protected abstract void checkForSink(AbstractCfgNode cfgNodeX, TacFunction traversedFunction, List<Sink> sinks);

	public List<Sink> collectSinks() {
		List<Sink> sinks = new LinkedList<Sink>();
		for (TacFunction function : this.depAnalysis.getFunctions()) {
			for (Iterator<?> iter = function.getCfg().dfPreOrder().iterator(); iter.hasNext();) {
				AbstractCfgNode cfgNodeX = (AbstractCfgNode) iter.next();
				checkForSink(cfgNodeX, function, sinks);
			}
		}
		return sinks;
	}

	protected boolean isStrongSanit(String opName) {
		return this.dci.getFunctionModels().getF_strongSanit().contains(opName);
	}

	protected boolean isWeakSanit(String opName, List<Integer> indices) {
		Set<Integer> i = this.dci.getFunctionModels().getF_weakSanit().get(opName);
		if (i == null) {
			return false;
		}
		indices.addAll(i);
		return true;
	}

	protected boolean isEvil(String opName) {
		return this.dci.getFunctionModels().getF_evil().contains(opName);
	}

	protected boolean isMulti(String opName, List<Integer> indices) {
		Set<Integer> i = this.dci.getFunctionModels().getF_multi().get(opName);
		if (i == null) {
			return false;
		}
		indices.addAll(i);
		return true;
	}

	protected boolean isInverseMulti(String opName, List<Integer> indices) {
		Set<Integer> i = this.dci.getFunctionModels().getF_invMulti().get(opName);
		if (i == null) {
			return false;
		}
		indices.addAll(i);
		return true;
	}

	protected AbstractVulnerabilityAnalysis.InitialTaint initiallyTainted(AbstractTacPlace place) {

		if (place instanceof Variable) {
			Variable var = place.getVariable();
			String varName = var.getName();

			if (var.isSuperGlobal()) {

				if (var.isReturnVariable()) {
					return AbstractVulnerabilityAnalysis.InitialTaint.NEVER;

				} else if (MyOptions.isHarmlessServerVar(varName) || varName.equals("$_SERVER")) {

					return AbstractVulnerabilityAnalysis.InitialTaint.NEVER;

				} else if (varName.startsWith("$_SESSION[")) {

					return AbstractVulnerabilityAnalysis.InitialTaint.NEVER;

				} else if (varName.equals("$_ENV") || varName.equals("$_HTTP_ENV_VARS") || varName.startsWith("$_ENV[")
						|| varName.startsWith("$HTTP_ENV_VARS[")) {

					return AbstractVulnerabilityAnalysis.InitialTaint.NEVER;

				} else if (!this.getIsTainted && varName.startsWith("$_GET[")) {

					return AbstractVulnerabilityAnalysis.InitialTaint.NEVER;

				} else {

					return AbstractVulnerabilityAnalysis.InitialTaint.ALWAYS;
				}

			} else {

				if (var.getSymbolTable().getName().equals("_special")) {

					if (varName.equals(InternalStrings.memberName)) {

						return AbstractVulnerabilityAnalysis.InitialTaint.NEVER;
					}

				} else if (varName.equals("$PHPSESSID")) {

					return AbstractVulnerabilityAnalysis.InitialTaint.NEVER;

				} else if (MyOptions.harmlessServerIndices.contains(varName.substring(1))) {

					return AbstractVulnerabilityAnalysis.InitialTaint.NEVER;

				} else if (!var.getSymbolTable().isMain()) {

					return AbstractVulnerabilityAnalysis.InitialTaint.NEVER;

				} else {

					return AbstractVulnerabilityAnalysis.InitialTaint.IFRG;
				}
			}

		} else if (place instanceof Constant) {

			return AbstractVulnerabilityAnalysis.InitialTaint.NEVER;
		}

		return AbstractVulnerabilityAnalysis.InitialTaint.ALWAYS;

	}

	protected DependencyGraph getRelevant(DependencyGraph depGraph) {

		if (depGraph.getRoot() != null) {
			DependencyGraph relevant = new DependencyGraph(depGraph.getRoot());
			this.getRelevantHelper(relevant.getRoot(), relevant, depGraph);
			return relevant;
		}
		return null;
	}

	protected void getRelevantHelper(AbstractNode node, DependencyGraph relevant, DependencyGraph orig) {

		if (node instanceof NormalNode) {

			for (AbstractNode succ : orig.getSuccessors(node)) {

				if (relevant.containsNode(succ)) {
					relevant.addEdge(node, succ);
					continue;
				}

				relevant.addNode(succ);
				relevant.addEdge(node, succ);
				getRelevantHelper(succ, relevant, orig);
			}

		} else if (node instanceof BuiltinFunctionNode) {

			BuiltinFunctionNode opNode = (BuiltinFunctionNode) node;
			String opName = opNode.getName();

			List<Integer> multiList = new LinkedList<Integer>();

			if (!opNode.isBuiltin()) {

				AbstractCfgNode cfgNodeX = opNode.getCfgNode();
				if (cfgNodeX instanceof CallUnknownFunction) {
					CallUnknownFunction callUnknown = (CallUnknownFunction) cfgNodeX;
					if (callUnknown.isMethod()) {
						AbstractNode sanitNode = new NormalNode(new Literal("<method-call>"), opNode.getCfgNode());
						relevant.addNode(sanitNode);
						relevant.addEdge(opNode, sanitNode);
					} else {
						AbstractNode uninitNode = new UninitializedNode();
						relevant.addNode(uninitNode);
						relevant.addEdge(opNode, uninitNode);
					}
				} else {
					throw new RuntimeException("SNH");
				}

			} else if (isStrongSanit(opName)) {

				AbstractNode sanitNode = new NormalNode(new Literal("<sanitization>"), opNode.getCfgNode());
				relevant.addNode(sanitNode);
				relevant.addEdge(opNode, sanitNode);

			} else if (isWeakSanit(opName, multiList)) {

				multiDependencyRelevant(opNode, relevant, orig, multiList, false);

			} else if (isEvil(opName)) {

				AbstractNode uninitNode = new UninitializedNode();
				relevant.addNode(uninitNode);
				relevant.addEdge(opNode, uninitNode);

			} else if (isMulti(opName, multiList)) {

				multiDependencyRelevant(opNode, relevant, orig, multiList, false);

			} else if (isInverseMulti(opName, multiList)) {

				multiDependencyRelevant(opNode, relevant, orig, multiList, true);

			} else {

				AbstractNode uninitNode = new UninitializedNode();
				relevant.addNode(uninitNode);
				relevant.addEdge(opNode, uninitNode);

			}

		} else if (node instanceof UninitializedNode) {

		} else {
			throw new RuntimeException("SNH: " + node.getClass());
		}
	}

	protected void multiDependencyRelevant(BuiltinFunctionNode opNode, DependencyGraph relevant, DependencyGraph orig,
			List<Integer> indices, boolean inverse) {

		List<AbstractNode> succs = orig.getSuccessors(opNode);
		Set<Integer> indexSet = new HashSet<Integer>(indices);

		int count = -1;
		boolean created = false;
		for (AbstractNode succ : succs) {
			count++;

			if (inverse) {
				if (indexSet.contains(count)) {
					continue;
				}
			} else {
				if (!indexSet.contains(count)) {
					continue;
				}
			}

			created = true;

			if (relevant.containsNode(succ)) {
				relevant.addEdge(opNode, succ);
				continue;
			}
			relevant.addNode(succ);
			relevant.addEdge(opNode, succ);
			this.getRelevantHelper(succ, relevant, orig);
		}

		if (!created) {
			AbstractNode sanitNode = new NormalNode(new Literal("<no-dep>"), opNode.getCfgNode());
			relevant.addNode(sanitNode);
			relevant.addEdge(opNode, sanitNode);
		}
	}

	protected Map<UninitializedNode, InitialTaint> findDangerousUninit(DependencyGraph relevant) {

		Set<UninitializedNode> uninitNodes = relevant.getUninitNodes();

		Map<UninitializedNode, InitialTaint> retMe = new HashMap<UninitializedNode, InitialTaint>();

		for (Iterator<UninitializedNode> iter = uninitNodes.iterator(); iter.hasNext();) {
			UninitializedNode uninitNode = (UninitializedNode) iter.next();
			Set<AbstractNode> preds = relevant.getPredecessors(uninitNode);
			if (preds.size() != 1) {
				throw new RuntimeException("SNH");
			}
			AbstractNode pre = preds.iterator().next();
			if (pre instanceof NormalNode) {
				NormalNode preNormal = (NormalNode) pre;
				switch (this.initiallyTainted(preNormal.getPlace())) {
				case ALWAYS:
					retMe.put(uninitNode, InitialTaint.ALWAYS);
					break;
				case IFRG:
					retMe.put(uninitNode, InitialTaint.IFRG);
					break;
				case NEVER:
					break;
				default:
					throw new RuntimeException("SNH");
				}
			} else if (pre instanceof BuiltinFunctionNode) {
				retMe.put(uninitNode, InitialTaint.ALWAYS);
			} else {
				throw new RuntimeException("SNH");
			}
		}

		return retMe;
	}

	protected List<NormalNode> findDangerousSources(DependencyGraph relevant) {

		List<NormalNode> retMe = new LinkedList<NormalNode>();

		Set<UninitializedNode> uninitNodes = this.findDangerousUninit(relevant).keySet();
		for (UninitializedNode uninitNode : uninitNodes) {

			Set<AbstractNode> preds = relevant.getPredecessors(uninitNode);
			if (preds.size() != 1) {
				throw new RuntimeException("SNH");
			}
			AbstractNode pre = preds.iterator().next();
			if (pre instanceof NormalNode) {
				NormalNode preNormal = (NormalNode) pre;
				retMe.add(preNormal);
			} else if (pre instanceof BuiltinFunctionNode) {

			} else {
				throw new RuntimeException("SNH");
			}
		}

		return retMe;
	}

}
