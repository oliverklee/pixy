package at.ac.tuwien.infosys.www.pixy;

import at.ac.tuwien.infosys.www.pixy.analysis.dependency.DependencyAnalysis;
import at.ac.tuwien.infosys.www.pixy.analysis.dependency.Sink;
import at.ac.tuwien.infosys.www.pixy.analysis.dependency.graph.*;
import at.ac.tuwien.infosys.www.pixy.conversion.*;
import at.ac.tuwien.infosys.www.pixy.conversion.cfgnodes.AbstractCfgNode;
import at.ac.tuwien.infosys.www.pixy.conversion.cfgnodes.CallUnknownFunction;

import java.util.*;

/**
 * If you want to create a new vulnerability analysis:
 * 1. inherit from this class (see existing examples)
 * 2. add info to MyOptions.analyses
 * 3. add model and sink config files
 *
 * @author Nenad Jovanovic <enji@seclab.tuwien.ac.at>
 */
public abstract class AbstractVulnerabilityAnalysis {
    protected DependencyAnalysis dependencyAnalysis;
    protected VulnerabilityAnalysisInformation vulnerabilityAnalysisInformation;

    /**
     * Flags returned by initiallyTainted():
     * - always tainted
     * - tainted if register_globals is active
     */
    public enum InitialTaint {ALWAYS, IF_REGISTER_GLOBALS, NEVER}

    /**
     * Should members of the $_GET array be considered as initially tainted? Defaults to true, of course.
     */
    protected boolean getIsTainted = true;

    protected AbstractVulnerabilityAnalysis(DependencyAnalysis dependencyAnalysis) {
        this.dependencyAnalysis = dependencyAnalysis;
        this.vulnerabilityAnalysisInformation = MyOptions.getVulnerabilityAnalysisInformation(this.getClass().getName());
    }

    /**
     * Detects vulnerabilities and returns a list with the line numbers of the detected vulnerabilities.
     *
     * @return the line numbers of the detected vulnerabilities
     */
    public abstract List<Integer> detectVulnerabilities();

    public abstract VulnerabilityInformation detectAlternative();

    /**
     * Checks if the given node (inside the given function) is a sensitive sink.
     *
     * Adds an appropriate sink object to the given list if it is a sink.
     *
     * @param cfgNodeX
     * @param traversedFunction
     * @param sinks
     */
    protected abstract void checkForSink(AbstractCfgNode cfgNodeX, TacFunction traversedFunction, List<Sink> sinks);

    /**
     * Returns a list of sinks for this analysis.
     *
     * @return
     */
    public List<Sink> collectSinks() {
        List<Sink> sinks = new LinkedList<>();
        for (TacFunction function : this.dependencyAnalysis.getFunctions()) {
            for (AbstractCfgNode cfgNode : function.getControlFlowGraph().dfPreOrder()) {
                checkForSink(cfgNode, function, sinks);
            }
        }
        return sinks;
    }

    protected boolean isStrongSanitation(String opName) {
        return this.vulnerabilityAnalysisInformation.getFunctionModels().getF_strongSanit().contains(opName);
    }

    protected boolean isWeakSanitation(String opName, List<Integer> indices) {
        Set<Integer> i = this.vulnerabilityAnalysisInformation.getFunctionModels().getF_weakSanit().get(opName);
        if (i == null) {
            return false;
        }

        indices.addAll(i);
        return true;
    }

    protected boolean isEvil(String opName) {
        return this.vulnerabilityAnalysisInformation.getFunctionModels().getF_evil().contains(opName);
    }

    /**
     * If the given operation is a multi-dependency operation, it returns true and fills the given indices list with the
     * appropriate index numbers.
     *
     * @param operationName
     * @param indices
     *
     * @return
     */
    protected boolean isMultiDependencyOperation(String operationName, List<Integer> indices) {
        Set<Integer> i = this.vulnerabilityAnalysisInformation.getFunctionModels().getF_multi().get(operationName);
        if (i == null) {
            return false;
        }
        indices.addAll(i);

        return true;
    }

    /**
     * Analogous to isMultiDependencyOperation, but inverse: e.g., if some function is an inverse
     * multi-dependency with a returned index "2", then all its parameters are relevant, except for parameter #2.
     *
     * @param operationName
     * @param indices
     * @return
     */
    protected boolean isInverseMultiDependencyOperation(String operationName, List<Integer> indices) {
        Set<Integer> i = this.vulnerabilityAnalysisInformation.getFunctionModels().getF_invMulti().get(operationName);
        if (i == null) {
            return false;
        }
        indices.addAll(i);
        return true;
    }

    protected AbstractVulnerabilityAnalysis.InitialTaint initiallyTainted(AbstractTacPlace place) {
        if (place instanceof Variable) {
            Variable var = place.getVariable();
            String varName = var.getName();

            // harmless superglobals?
            if (var.isSuperGlobal()) {
                // return variables
                if (var.isReturnVariable()) {
                    return AbstractVulnerabilityAnalysis.InitialTaint.NEVER;
                } else if (MyOptions.isHarmlessServerVar(varName) ||
                    varName.equals("$_SERVER")) {
                    // harmless member of the SERVER array,
                    // or the SERVER array itself
                    return AbstractVulnerabilityAnalysis.InitialTaint.NEVER;
                } else if (varName.startsWith("$_SESSION[")) {
                    // the whole session array
                    return AbstractVulnerabilityAnalysis.InitialTaint.NEVER;
                } else if (varName.equals("$_ENV") ||
                    varName.equals("$_HTTP_ENV_VARS") ||
                    varName.startsWith("$_ENV[") ||
                    varName.startsWith("$HTTP_ENV_VARS[")) {
                    // the whole env array
                    return AbstractVulnerabilityAnalysis.InitialTaint.NEVER;
                } else if (!this.getIsTainted && varName.startsWith("$_GET[")) {
                    // the whole GET array, if it shall be considered
                    // as not tainted
                    return AbstractVulnerabilityAnalysis.InitialTaint.NEVER;
                } else {
                    // non-harmless superglobal
                    return AbstractVulnerabilityAnalysis.InitialTaint.ALWAYS;
                }
                // non-superglobals
            } else {
                if (var.getSymbolTable().getName().equals("_special")) {
                    if (varName.equals(InternalStrings.memberName)) {
                        return AbstractVulnerabilityAnalysis.InitialTaint.NEVER;
                    }
                } else if (varName.equals("$PHPSESSID")) {
                    // the special php session id variable is harmless
                    return AbstractVulnerabilityAnalysis.InitialTaint.NEVER;
                } else if (MyOptions.harmlessServerIndices.contains(varName.substring(1))) {
                    // something like $SERVER_NAME etc.
                    // (i.e. harmless indices of the SERVER array that have been
                    // exported into main's scope due to register_globals
                    return AbstractVulnerabilityAnalysis.InitialTaint.NEVER;
                } else if (!var.getSymbolTable().isMain()) {
                    // local function variables are untainted
                    return AbstractVulnerabilityAnalysis.InitialTaint.NEVER;
                } else {
                    // a global variable
                    if (!MyOptions.optionG) {
                        // if the user decided to disable register_globals,
                        // ignore these cases
                        return AbstractVulnerabilityAnalysis.InitialTaint.NEVER;
                    } else {
                        return AbstractVulnerabilityAnalysis.InitialTaint.IF_REGISTER_GLOBALS;
                    }
                }
            }
        } else if (place instanceof Constant) {
            // uninitialized constants are untainted
            return AbstractVulnerabilityAnalysis.InitialTaint.NEVER;
        }

        // did we miss something? everything else is tainted
        return AbstractVulnerabilityAnalysis.InitialTaint.ALWAYS;
    }

    /**
     * Extracts the "relevant subgraph", using models for builtin functions.
     *
     * Here is how it works:
     *
     * - for operation nodes representing sanitization functions, the top-down algorithm
     * doesn't follow its successors; instead, a single new successor ("<sanitation>")
     * is created
     * - evil functions: a single <uninit> successor is created
     * - multi-dependency: the algorithm only follows those successors that are defined as relevant for XSS
     * - unmodeled functions are treated as if they were evil functions
     *
     * @param dependencyGraph
     *
     * @return
     */
    protected DependencyGraph getRelevantSubgraph(DependencyGraph dependencyGraph) {
        // start with a one-element graph
        DependencyGraph relevant = new DependencyGraph(dependencyGraph.getRoot());
        this.getRelevantHelper(relevant.getRoot(), relevant, dependencyGraph);
        return relevant;
    }

    protected void getRelevantHelper(AbstractNode node, DependencyGraph relevant, DependencyGraph orig) {
        if (node instanceof NormalNode) {
            for (AbstractNode successor : orig.getSuccessors(node)) {
                // if this node has already been added to the relevant graph...
                if (relevant.containsNode(successor)) {
                    relevant.addEdge(node, successor);
                    continue;
                }

                relevant.addNode(successor);
                relevant.addEdge(node, successor);
                getRelevantHelper(successor, relevant, orig);
            }
        } else if (node instanceof BuiltinFunctionNode) {
            BuiltinFunctionNode builtinFunctionNode = (BuiltinFunctionNode) node;
            String opName = builtinFunctionNode.getName();
            // list for indices of multi-dependency functions
            List<Integer> multiList = new LinkedList<>();

            if (!builtinFunctionNode.isBuiltin()) {
                // call to function or method for which no definition
                // could be found
                AbstractCfgNode cfgNodeX = builtinFunctionNode.getCfgNode();
                if (cfgNodeX instanceof CallUnknownFunction) {
                    CallUnknownFunction callUnknown = (CallUnknownFunction) cfgNodeX;
                    if (callUnknown.isMethod()) {
                        AbstractNode sanitNode = new NormalNode(
                            new Literal("<method-call>"), builtinFunctionNode.getCfgNode());
                        relevant.addNode(sanitNode);
                        relevant.addEdge(builtinFunctionNode, sanitNode);
                    } else {
                        AbstractNode uninitNode = new UninitializedNode();
                        relevant.addNode(uninitNode);
                        relevant.addEdge(builtinFunctionNode, uninitNode);
                    }
                } else {
                    throw new RuntimeException("SNH");
                }
                // end of recursion

                // STRONG SANITIZATION FUNCTIONS ************************
            } else if (isStrongSanitation(opName)) {
                AbstractNode sanitNode = new NormalNode(
                    new Literal("<sanitization>"), builtinFunctionNode.getCfgNode());
                relevant.addNode(sanitNode);
                relevant.addEdge(builtinFunctionNode, sanitNode);
                // end of recursion

                // WEAK SANITIZATION FUNCTIONS ************************
            } else if (isWeakSanitation(opName, multiList)) {
                multiDependencyRelevant(builtinFunctionNode, relevant, orig, multiList, false);

                // EVIL FUNCTIONS ***************************************
            } else if (isEvil(opName)) {
                AbstractNode uninitNode = new UninitializedNode();
                relevant.addNode(uninitNode);
                relevant.addEdge(builtinFunctionNode, uninitNode);
                // end of recursion

                // MULTI-OR-DEPENDENCY **********************************

                // TODO: generic value flows should better be modeled during
                // depgraph construction, and not here
            } else if (isMultiDependencyOperation(opName, multiList)) {
                multiDependencyRelevant(builtinFunctionNode, relevant, orig, multiList, false);

                // INVERSE MULTI-OR-DEPENDENCY **************************
            } else if (isInverseMultiDependencyOperation(opName, multiList)) {
                multiDependencyRelevant(builtinFunctionNode, relevant, orig, multiList, true);

                // CATCH-ALL ********************************************
            } else {
                System.out.println("Unmodeled builtin function: " + opName);
                AbstractNode uninitNode = new UninitializedNode();
                relevant.addNode(uninitNode);
                relevant.addEdge(builtinFunctionNode, uninitNode);
                // end of recursion
            }
        } else if (node instanceof UninitializedNode) {
            // end of recursion: this is always a leaf node
        } else {
            throw new RuntimeException("SNH: " + node.getClass());
        }
    }

    /**
     * Helper function for multi-dependency builtin functions (in relevant subgraph construction).
     *
     * @param builtinFunctionNode
     * @param relevant
     * @param orig
     * @param indices
     * @param inverse
     */
    protected void multiDependencyRelevant(
        BuiltinFunctionNode builtinFunctionNode, DependencyGraph relevant, DependencyGraph orig, List<Integer> indices,
        boolean inverse
    ) {
        List<AbstractNode> successors = orig.getSuccessors(builtinFunctionNode);
        Set<Integer> indexSet = new HashSet<>(indices);

        int count = -1;
        boolean created = false;
        for (AbstractNode successor : successors) {
            count++;

            // check if there is a dependency on this successor
            if (inverse) {
                if (indexSet.contains(count)) {
                    continue;
                }
            } else {
                if (!indexSet.contains(count)) {
                    continue;
                }
            }

            created = true;

            if (relevant.containsNode(successor)) {
                relevant.addEdge(builtinFunctionNode, successor);
                continue;
            }
            relevant.addNode(successor);
            relevant.addEdge(builtinFunctionNode, successor);
            this.getRelevantHelper(successor, relevant, orig);
        }

        if (!created) {
            // if no successors have been created: make a harmless one
            AbstractNode sanitNode = new NormalNode(
                new Literal("<no-dep>"), builtinFunctionNode.getCfgNode());
            relevant.addNode(sanitNode);
            relevant.addEdge(builtinFunctionNode, sanitNode);
        }
    }

    /**
     * Finds those uninitialized nodes in the given *relevant* depgraph that are dangerous.
     * @param relevant
     * @return
     */
    protected Map<UninitializedNode, InitialTaint> findDangerousUninitializedNodes(DependencyGraph relevant) {
        Set<UninitializedNode> uninitializedNodes = relevant.getUninitNodes();

        Map<UninitializedNode, InitialTaint> retMe = new HashMap<>();

        for (UninitializedNode uninitializedNode : uninitializedNodes) {
            Set<AbstractNode> predecessors = relevant.getPredecessors(uninitializedNode);
            if (predecessors.size() != 1) {
                throw new RuntimeException("SNH");
            }
            AbstractNode predecessor = predecessors.iterator().next();
            if (predecessor instanceof NormalNode) {
                NormalNode preNormal = (NormalNode) predecessor;
                switch (this.initiallyTainted(preNormal.getPlace())) {
                    case ALWAYS:
                        retMe.put(uninitializedNode, InitialTaint.ALWAYS);
                        break;
                    case IF_REGISTER_GLOBALS:
                        retMe.put(uninitializedNode, InitialTaint.IF_REGISTER_GLOBALS);
                        break;
                    case NEVER:
                        // nothing to do here
                        break;
                    default:
                        throw new RuntimeException("SNH");
                }
            } else if (predecessor instanceof BuiltinFunctionNode) {
                // evil function, don't remove
                retMe.put(uninitializedNode, InitialTaint.ALWAYS);
            } else {
                throw new RuntimeException("SNH");
            }
        }

        return retMe;
    }

    protected List<NormalNode> findDangerousSources(DependencyGraph relevant) {
        List<NormalNode> retMe = new LinkedList<>();

        // get dangerous uninitialized nodes, and then inspect their predecessors
        Set<UninitializedNode> uninitializedNodes = this.findDangerousUninitializedNodes(relevant).keySet();
        for (UninitializedNode uninitializedNode : uninitializedNodes) {

            Set<AbstractNode> predecessors = relevant.getPredecessors(uninitializedNode);
            if (predecessors.size() != 1) {
                throw new RuntimeException("SNH");
            }
            AbstractNode predecessor = predecessors.iterator().next();
            if (predecessor instanceof NormalNode) {
                NormalNode preNormal = (NormalNode) predecessor;
                retMe.add(preNormal);
            } else if (predecessor instanceof BuiltinFunctionNode) {
                // evil function, ignore
            } else {
                throw new RuntimeException("SNH");
            }
        }

        return retMe;
    }
}